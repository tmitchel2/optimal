/**
 * Copyright (c) Small Trading Company Ltd (Destash.com).
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Optimal.Analyzers
{
    [Generator]
    public class OptimalIncrementalSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            GeneratorLogging.SetLoggingLevel(LoggingLevel.Fatal);
            GeneratorLogging.SetLogFilePath("/Users/tom/GitHub/optimal/src/Optimal.Analyzers/OptimalIncrementalSourceGeneratorLog.txt");
            try
            {
                context.RegisterPostInitializationOutput(static postInitializationContext =>
                {
                    // postInitializationContext.AddEmbeddedAttributeDefinition();
                    postInitializationContext.AddSource("OptimalAttributes.g.cs", SourceText.From("""
                // <auto-generated/>

                #nullable enable annotations
                #nullable disable warnings

                // Suppress warnings
                #pragma warning disable CS0612, CS0618, CS9113, CS1591

                using System;
                using Microsoft.CodeAnalysis;

                namespace Optimal
                {
                    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
                    internal sealed class OptimalCodeAttribute : Attribute
                    {
                    }
                }
                """, Encoding.UTF8));
                });

                var graphNodeProvider = context
                    .SyntaxProvider
                    .ForAttributeWithMetadataName(
                        "GraphlessDB.GraphlessDBSchemaAttribute",
                        predicate: static (node, cancelToken) => HasOptimalAttribute(node),
                        transform: static (ctx, cancelToken) => GetTransform(ctx));

                context.RegisterSourceOutput(
                    graphNodeProvider,
                    (sourceProductionContext, source) => Generate(source, sourceProductionContext));
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static void Generate(OptimalTransform graph, SourceProductionContext context)
        {
            try
            {

            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static bool HasOptimalAttribute(SyntaxNode node)
        {
            try
            {
                GeneratorLogging.LogMessage($"HasOptimalAttribute");
                return node is ClassDeclarationSyntax classDeclaration && classDeclaration
                    .AttributeLists
                    .SelectMany(a => a.Attributes)
                    .Where(IsOptimalAttribute)
                    .Any();
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static bool IsOptimalAttribute(AttributeSyntax attribute)
        {
            GeneratorLogging.LogMessage($"IsOptimalAttribute");
            return attribute.Name.GetText().ToString() == "Optimal";
        }

        private static bool IsOptimalAttribute(AttributeData attribute)
        {
            GeneratorLogging.LogMessage($"IsOptimalAttribute");
            return attribute.AttributeClass?.Name == "OptimalAttribute";
        }

        private static OptimalTransform GetTransform(GeneratorAttributeSyntaxContext ctx)
        {
            try
            {
                var attributeList = ctx.Attributes.ToList();
                GeneratorLogging.LogMessage($"GetTransform [{attributeList.Count} attributes]");
                return attributeList
                    .Where(IsOptimalAttribute)
                    .Select(GetTransform)
                    .Aggregate(new OptimalTransform(), (acc, cur) => acc.Add(cur));
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static OptimalTransform GetTransform(AttributeData attribute)
        {
            GeneratorLogging.LogMessage("GetTransform");
            return new OptimalTransform();
        }
    }

    public sealed record OptimalTransform()
    {
        public OptimalTransform Add(OptimalTransform other)
        {
            return this;
        }
    }
}
