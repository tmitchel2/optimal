/**
 * Copyright (c) Small Trading Company Ltd (Destash.com).
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Optimal.Analyzers
{
    [Generator]
    public class OptimalIncrementalSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            GeneratorLogging.SetLoggingLevel(LoggingLevel.Fatal);
            GeneratorLogging.SetLogFilePath("/Users/tom/GitHub/optimal/src/Optimal.Analyzers/OptimalIncrementalSourceGeneratorLog.txt");
            try
            {
                context.RegisterPostInitializationOutput(static postInitializationContext =>
                {
                    // postInitializationContext.AddEmbeddedAttributeDefinition();
                    postInitializationContext.AddSource("OptimalAttributes.g.cs", SourceText.From("""
                // <auto-generated/>

                #nullable enable annotations
                #nullable disable warnings

                // Suppress warnings
                #pragma warning disable CS0612, CS0618, CS9113, CS1591

                using System;
                using Microsoft.CodeAnalysis;

                namespace Optimal
                {
                    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
                    internal sealed class OptimalCodeAttribute : Attribute
                    {
                    }
                }
                """, Encoding.UTF8));
                });

                var compilationProvider = context.CompilationProvider;

                var graphNodeProvider = context
                    .SyntaxProvider
                    .ForAttributeWithMetadataName(
                        "Optimal.OptimalCodeAttribute",
                        predicate: static (node, cancelToken) => HasOptimalAttribute(node),
                        transform: static (ctx, cancelToken) => GetTransform(ctx));

                var combined = graphNodeProvider.Combine(compilationProvider);

                context.RegisterSourceOutput(
                    combined,
                    (sourceProductionContext, source) => Generate(source.Left, source.Right, sourceProductionContext));
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static void Generate(OptimalTransform transform, Compilation compilation, SourceProductionContext context)
        {
            try
            {
                if (transform.ClassSymbol == null || transform.ClassName == null || !transform.Methods.Any())
                {
                    return;
                }

                GeneratorLogging.LogMessage($"Generating code for class: {transform.ClassName}");

                var doubleType = compilation.GetSpecialType(SpecialType.System_Double);

                var codeGenerator = new CodeGen.ForwardModeCodeGenerator(doubleType);

                var sb = new StringBuilder();

                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
                sb.AppendLine("#pragma warning disable CS0219 // Variable assigned but never used");
                sb.AppendLine();

                var namespaces = CollectNamespaces(transform);
                foreach (var ns in namespaces.OrderBy(n => n))
                {
                    sb.AppendLine($"using {ns};");
                }
                sb.AppendLine();

                var namespaceName = string.IsNullOrEmpty(transform.Namespace)
                    ? "Generated"
                    : transform.Namespace;

                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");

                sb.AppendLine($"    public static class {transform.ClassName}Gradients");
                sb.AppendLine("    {");

                foreach (var method in transform.Methods)
                {
                    GeneratorLogging.LogMessage($"  Generating gradients for method: {method.MethodName}");

                    if (!method.DifferentiableParameters.Any())
                    {
                        GeneratorLogging.LogMessage($"    Skipping (no differentiable parameters)");
                        continue;
                    }

                    foreach (var param in method.DifferentiableParameters)
                    {
                        GeneratorLogging.LogMessage($"    Generating forward mode w.r.t. {param.Name}");
                        var forwardCode = codeGenerator.GenerateMethod(method, param, doubleType);
                        sb.Append(forwardCode);
                        sb.AppendLine();
                    }

                    if (method.DifferentiableParameters.Length > 1)
                    {
                        try
                        {
                            GeneratorLogging.LogMessage($"    Generating reverse mode (all parameters)");
                            var reverseGenerator = new CodeGen.ReverseModeCodeGenerator(doubleType);
                            var reverseCode = reverseGenerator.GenerateMethod(method, doubleType);
                            sb.Append(reverseCode);
                            sb.AppendLine();
                        }
                        catch (NotSupportedException ex)
                        {
                            GeneratorLogging.LogMessage($"    Skipping reverse mode: {ex.Message}");
                        }
                    }
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);
                context.AddSource($"{transform.ClassName}Gradients.g.cs", sourceText);

                GeneratorLogging.LogMessage($"Successfully generated {transform.ClassName}Gradients.g.cs");
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static HashSet<string> CollectNamespaces(OptimalTransform transform)
        {
            var namespaces = new HashSet<string> { "System" };

            foreach (var method in transform.Methods)
            {
                foreach (var param in method.Parameters)
                {
                    var ns = param.Type.ContainingNamespace?.ToDisplayString();
                    if (!string.IsNullOrEmpty(ns) && ns != "System")
                    {
                        _ = namespaces.Add(ns!);
                    }
                }

                var returnNs = method.ReturnType.ContainingNamespace?.ToDisplayString();
                if (!string.IsNullOrEmpty(returnNs) && returnNs != "System")
                {
                    _ = namespaces.Add(returnNs!);
                }
            }

            return namespaces;
        }

        private static bool HasOptimalAttribute(SyntaxNode node)
        {
            try
            {
                GeneratorLogging.LogMessage($"HasOptimalAttribute");
                return node is ClassDeclarationSyntax classDeclaration && classDeclaration
                    .AttributeLists
                    .SelectMany(a => a.Attributes)
                    .Where(IsOptimalAttribute)
                    .Any();
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static bool IsOptimalAttribute(AttributeSyntax attribute)
        {
            GeneratorLogging.LogMessage($"IsOptimalAttribute");
            var name = attribute.Name.GetText().ToString();
            return name == "OptimalCode" || name == "Optimal";
        }

        private static bool IsOptimalAttribute(AttributeData attribute)
        {
            GeneratorLogging.LogMessage($"IsOptimalAttribute");
            return attribute.AttributeClass?.Name == "OptimalCodeAttribute";
        }

        private static OptimalTransform GetTransform(GeneratorAttributeSyntaxContext ctx)
        {
            try
            {
                var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
                var classSyntax = (ClassDeclarationSyntax)ctx.TargetNode;

                GeneratorLogging.LogMessage($"GetTransform for class: {classSymbol.Name}");

                var className = classSymbol.Name;
                var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                    ? string.Empty
                    : classSymbol.ContainingNamespace.ToDisplayString();

                var methodsList = new List<MethodToTransform>();

                foreach (var methodSymbol in classSymbol.GetMembers()
                    .OfType<IMethodSymbol>()
                    .Where(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public && m.MethodKind == MethodKind.Ordinary))
                {
                    var methodSyntax = classSyntax.Members
                        .OfType<MethodDeclarationSyntax>()
                        .FirstOrDefault(m => m.Identifier.Text == methodSymbol.Name &&
                            m.ParameterList.Parameters.Count == methodSymbol.Parameters.Length);

                    if (methodSyntax == null)
                    {
                        continue;
                    }

                    var parameters = AnalyzeParameters(methodSymbol);
                    var differentiableParameters = parameters
                        .Where(p => p.IsDifferentiable)
                        .ToImmutableArray();

                    GeneratorLogging.LogMessage($"  Method: {methodSymbol.Name}, Differentiable params: {differentiableParameters.Length}");

                    methodsList.Add(new MethodToTransform(
                        methodSymbol,
                        methodSymbol.Name,
                        parameters,
                        methodSymbol.ReturnType,
                        methodSyntax,
                        ctx.SemanticModel,
                        differentiableParameters,
                        methodSymbol.IsStatic));
                }

                var methods = methodsList.ToImmutableArray();

                return new OptimalTransform(classSymbol, className, namespaceName, methods);
            }
            catch (Exception ex)
            {
                GeneratorLogging.LogMessage(ex.ToString(), LoggingLevel.Error);
                throw;
            }
        }

        private static ImmutableArray<ParameterInfo> AnalyzeParameters(IMethodSymbol methodSymbol)
        {
            return methodSymbol.Parameters
                .Select((param, index) => new ParameterInfo(
                    param.Name,
                    param.Type,
                    IsDifferentiableType(param.Type),
                    index))
                .ToImmutableArray();
        }

        private static bool IsDifferentiableType(ITypeSymbol type)
        {
            var typeName = type.ToDisplayString();
            return typeName == "double" || typeName == "float" || typeName == "System.Double" || typeName == "System.Single";
        }
    }

    public sealed record OptimalTransform(
        INamedTypeSymbol? ClassSymbol,
        string? ClassName,
        string? Namespace,
        ImmutableArray<MethodToTransform> Methods)
    {
        public OptimalTransform() : this(null, null, null, ImmutableArray<MethodToTransform>.Empty)
        {
        }

        public OptimalTransform Add(OptimalTransform other)
        {
            if (other.ClassSymbol == null)
            {
                return this;
            }

            return new OptimalTransform(
                other.ClassSymbol ?? ClassSymbol,
                other.ClassName ?? ClassName,
                other.Namespace ?? Namespace,
                Methods.AddRange(other.Methods));
        }
    }

    public sealed record MethodToTransform(
        IMethodSymbol MethodSymbol,
        string MethodName,
        ImmutableArray<ParameterInfo> Parameters,
        ITypeSymbol ReturnType,
        MethodDeclarationSyntax MethodSyntax,
        SemanticModel SemanticModel,
        ImmutableArray<ParameterInfo> DifferentiableParameters,
        bool IsStatic);

    public sealed record ParameterInfo(
        string Name,
        ITypeSymbol Type,
        bool IsDifferentiable,
        int ParameterIndex);
}
